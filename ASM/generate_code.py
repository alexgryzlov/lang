import os

CODEGEN_DIR = "codegen"
COMMANDS_PATH = "commands.txt"
EXECUTE_PATH = "execute.cpp"
COMPILE_PATH = "compile.cpp"
CREATE_TRIE_PATH = "create_trie.cpp"
DISSASEMBLY_PATH = "disassembly.cpp"
LISTING_PATH = "listing.cpp"

def generate_file(path):
    if not os.path.exists(CODEGEN_DIR):
        os.mkdir(CODEGEN_DIR)
    file = open(CODEGEN_DIR + "/" + path, 'w')
    file.write("// THIS FILE IS AUTOGENERATED. DO NOT CHANGE ANYTHING.\n\n")
    return file

commands = open(COMMANDS_PATH, 'r')
execute = generate_file(EXECUTE_PATH)
compile = generate_file(COMPILE_PATH)
create_trie = generate_file(CREATE_TRIE_PATH)
disassembly = generate_file(DISSASEMBLY_PATH)
listing = generate_file(LISTING_PATH)


for line in commands:
    # data[0] - name, data[1] - code, data[2] - argc, data[3] - arg == reg?
    data = line.split()
    
    # Generate execute file
    execute.write(f"case {data[1]}: {{\n"
                  f"\t{data[0]}();\n"
                  f"\tbreak;\n}}\n")

    # Generate compile file
    if int(data[2]) > 0:
        compile.write(f"case {data[1]}: {{\n"
                      f"\tfor (size_t i = 0; i < {data[2]}; i++) {{\n"
                      f"\t\t++pc;\n")
        if int(data[3]) == 0:
            compile.write(f"\t\tcompiled_text[pc] = strtol(text[pc].ptr, NULL, 10);\n"
                           "\t}\n")
        elif int(data[3]) == 1:
            compile.write(f"\t\tcompiled_text[pc] = strtol(text[pc].ptr + 1, NULL, 10);\n"
                           "\t}\n")
        elif int(data[3]) == 2:
            compile.write(f"\t\ttmp.ptr = text[pc].ptr;\n\t\ttmp.len = text[pc].len;\n\t\tcompiled_text[pc] = label_trie.get_code(tmp);\n\t}}\n")
        compile.write("\tbreak;\n"
                      "}\n")
    
    # Generate trie initialisation
    command_size = len(data[0])
    create_trie.write(f"command_trie.insert({{ \"{data[0]}\", {command_size} }}, {data[1]});\n")

    # Generate disassembly
    disassembly.write(f"case {data[1]}: {{\n"
                      f"\tfprintf(intial, \"{data[0]}\");\n")
    if int(data[2]) > 0:
        disassembly.write(f"\tfor (size_t i = 0; i < {data[2]}; i++) {{\n"
                          f"\t\t++pc;\n")
        if int(data[3]) == 0:
            disassembly.write(f"\t\tfprintf(intial, \" %d\", compiled_text[pc]);\n")
        elif int(data[3]) == 1:
            disassembly.write(f"\t\tfprintf(intial, \" r%d\", compiled_text[pc]);\n")
        elif int(data[3]) == 2:
            disassembly.write(f"\t\tfprintf(intial, \" label%d\", compiled_text[compiled_text[pc]] & 0b1111);\n")

        disassembly.write("\t}\n")
    disassembly.write(f"\tfprintf(intial, \"\\n\");\n"
             f"\tbreak;\n}}\n")

    # Generate listing file
    fill_spaces = 30
    fill_string = (fill_spaces - 11 * int(data[2])) * ' '
    listing.write(f"case {data[1]}: {{\n"
                  f"\tfprintf(listing, \"%#010x\", {data[1]});\n")
    if int(data[2]) > 0:
        listing.write(f"\tfor (size_t i = 0; i < {data[2]}; i++) {{\n"
                      f"\t\t++pc1;\n"
                      f"\t\tfprintf(listing, \" %#010x\", compiled_text[pc1]);\n"
                      f"\t}}\n")
    listing.write(f"\tfprintf(listing, \"{fill_string}\");\n")
    listing.write(f"\tfprintf(listing, \";\");\n")
    listing.write(f"\tfprintf(listing, \"{data[0]}\");\n")
    if int(data[2]) > 0:
        listing.write(f"\tfor (size_t i = 0; i < {data[2]}; i++) {{\n"
                      f"\t\t++pc2;\n"
                      f"\t\tfprintf(listing, \" %s\", text[pc2].ptr);\n"
                      f"\t}}\n")
    listing.write(f"\tfprintf(listing, \"\\n\");\n"
                      f"\tbreak;\n}}\n")


execute.close()
compile.close()
commands.close()
create_trie.close()
disassembly.close()
listing.close()
    

